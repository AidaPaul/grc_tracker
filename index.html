<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UK GRC Document Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Combined Header with Progress */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 20px 18px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }

        .header .subtitle {
            font-size: 0.95rem;
            opacity: 0.9;
            margin-bottom: 15px;
        }

        .header-progress {
            margin-top: 15px;
        }

        .header-progress h2 {
            font-size: 1.1rem;
            margin-bottom: 10px;
            opacity: 0.95;
        }

        .master-progress-bar {
            width: 100%;
            height: 30px;
            background-color: rgba(255,255,255,0.2);
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .master-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7), rgba(255,255,255,0.9));
            background-size: 200% 100%;
            animation: shimmer 3s ease-in-out infinite;
            transition: width 0.8s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        @keyframes shimmer {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        .master-progress-text {
            color: #333;
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: none;
        }

        .master-progress-details {
            color: rgba(255,255,255,0.9);
            font-size: 0.85rem;
        }

        /* Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 968px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Progress Overview Card */
        .progress-overview {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .progress-overview h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .progress-item {
            margin-bottom: 20px;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.5s ease;
            position: relative;
        }

        .progress-fill.warning {
            background: linear-gradient(90deg, #ffc107, #ff9800);
        }

        .progress-fill.danger {
            background: linear-gradient(90deg, #dc3545, #c82333);
        }

        .progress-fill.success {
            background: linear-gradient(90deg, #28a745, #218838);
        }

        .progress-fill.eligible {
            background: linear-gradient(90deg, #28a745, #20c997);
            animation: celebrate 3s ease-in-out infinite;
        }

        @keyframes celebrate {
            0%, 100% { 
                background: linear-gradient(90deg, #28a745, #20c997);
                transform: scale(1);
            }
            50% { 
                background: linear-gradient(90deg, #20c997, #17a2b8);
                transform: scale(1.02);
            }
        }

        /* Stats Cards */
        .stats-overview {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .stat-number {
            font-size: 1.8rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }

        /* Evidence Timeline */
        .timeline-section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .timeline-header {
            margin-bottom: 25px;
        }

        .timeline-header h2 {
            color: #667eea;
            font-size: 1.5rem;
        }

        /* Timeline Grid View */
        .timeline-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .quarter-card {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .quarter-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }

        .quarter-card.completed {
            background: #f0f8f0;
            border-color: #28a745;
        }

        .quarter-card.current {
            background: #f0f4ff;
            border-color: #667eea;
        }

        .quarter-card.future {
            opacity: 0.7;
        }

        .quarter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .quarter-title {
            font-weight: bold;
            font-size: 1.1rem;
            color: #333;
        }

        .quarter-status {
            font-size: 1.5rem;
        }

        .quarter-dates {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 15px;
        }

        .quarter-progress {
            margin-bottom: 10px;
        }

        .mini-progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }

        .mini-progress-fill {
            height: 100%;
            background: #667eea;
            transition: width 0.3s ease;
        }

        .quarter-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
        }

        .quarter-action {
            text-align: center;
            margin-top: 15px;
            color: #667eea;
            font-weight: 500;
        }

        /* Document Categories */
        .categories-section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .category-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .category-tab {
            padding: 10px 20px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .category-tab:hover {
            border-color: #667eea;
        }

        .category-tab.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .category-badge {
            background: rgba(255,255,255,0.3);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: bold;
        }

        .category-content {
            display: none;
        }

        .category-content.active {
            display: block;
        }

        .document-list {
            display: grid;
            gap: 15px;
        }

        .document-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .document-item.completed {
            background: #f0f8f0;
            border-color: #28a745;
        }

        .document-item.required {
            border-color: #dc3545;
            background: #fff5f5;
        }

        .document-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 10px;
        }

        .document-title {
            font-weight: bold;
            font-size: 1.1rem;
            color: #333;
        }

        .document-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            padding: 4px 12px;
            border-radius: 20px;
            background: #e0e0e0;
        }

        .document-status.completed {
            background: #28a745;
            color: white;
        }

        .document-status.required {
            background: #dc3545;
            color: white;
        }

        .document-description {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .document-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal-content {
            background: white;
            margin: 50px auto;
            padding: 0;
            border-radius: 10px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 30px rgba(0,0,0,0.2);
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            font-size: 1.5rem;
            margin: 0;
        }

        .close-modal {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .close-modal:hover {
            background: rgba(255,255,255,0.2);
        }

        .modal-body {
            padding: 25px;
        }

        /* File Upload Area */
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            background: #f8f9ff;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            background: #f0f4ff;
            border-color: #5a6fd8;
        }

        .upload-area.drag-over {
            background: #e8ecff;
            border-color: #4a5fc8;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .upload-text {
            color: #667eea;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .upload-subtext {
            color: #666;
            font-size: 0.9rem;
        }

        /* File List */
        .file-list {
            margin-top: 20px;
        }

        .file-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #e0e0e0;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .file-icon {
            font-size: 2rem;
        }

        .file-details {
            text-align: left;
        }

        .file-name {
            font-weight: 500;
            margin-bottom: 3px;
        }

        .file-meta {
            font-size: 0.85rem;
            color: #666;
        }

        .file-actions {
            display: flex;
            gap: 10px;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-outline {
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
        }

        .btn-outline:hover {
            background: #667eea;
            color: white;
        }

        /* Notes */
        .notes-section {
            margin-top: 20px;
        }

        .notes-section h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .notes-textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            resize: vertical;
            font-family: inherit;
        }

        /* Export Section */
        .export-section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .export-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Loading Spinner */
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Migration Progress Overlay */
        #migration-overlay .spinner {
            border-top-color: white;
        }

        /* Alert Messages */
        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .alert-info {
            background: #cff4fc;
            color: #055160;
            border: 1px solid #b6effb;
        }

        .alert-success {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .alert-danger {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* Storage info */
        .storage-info {
            background: #e8f5e9;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .header .subtitle {
                font-size: 0.9rem;
            }

            .header-progress h2 {
                font-size: 1rem;
            }

            .timeline-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .category-tabs {
                flex-direction: column;
            }

            .category-tab {
                width: 100%;
            }

            .export-buttons {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè≥Ô∏è‚Äç‚ößÔ∏è UK GRC Document Tracker</h1>
            <p class="subtitle">Track your evidence collection during the mandatory waiting period</p>
            
            <div class="header-progress">
                <h2>Overall Application Progress</h2>
                <div class="master-progress-bar">
                    <div class="master-progress-fill" id="master-progress" style="width: 0%">
                        <span class="master-progress-text" id="master-progress-text">0%</span>
                    </div>
                </div>
                <div class="master-progress-details" id="master-progress-details">
                    Loading progress...
                </div>
            </div>
        </div>

        <div class="dashboard-grid">
            <div class="progress-overview">
                <h2 id="progress-overview-title">üìä Overall Progress</h2>
                
                <div class="progress-item">
                    <div class="progress-label">
                        <span>Time to Application</span>
                        <span id="timeline-countdown">Calculating...</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="timeline-progress" style="width: 0%"></div>
                    </div>
                    <small id="timeline-info">Started December 2023</small>
                </div>

                <div class="progress-item">
                    <div class="progress-label">
                        <span>Core Documents</span>
                        <span id="core-percentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill danger" id="core-progress" style="width: 0%"></div>
                    </div>
                    <small id="core-info">0 of 0 required documents</small>
                </div>

                <div class="progress-item">
                    <div class="progress-label">
                        <span>Medical Reports</span>
                        <span id="medical-percentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill warning" id="medical-progress" style="width: 0%"></div>
                    </div>
                    <small id="medical-info">0 of 2 reports</small>
                </div>

                <div class="progress-item">
                    <div class="progress-label">
                        <span>Evidence Collection</span>
                        <span id="evidence-percentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill success" id="evidence-progress" style="width: 0%"></div>
                    </div>
                    <small id="evidence-info">0 pieces collected (target: 16)</small>
                </div>

                <div class="progress-item">
                    <div class="progress-label">
                        <span>Name Change</span>
                        <span id="name-percentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="name-progress" style="width: 0%"></div>
                    </div>
                    <small id="name-info">0 documents uploaded</small>
                </div>

                <div class="progress-item">
                    <div class="progress-label">
                        <span>Marriage/Partnership</span>
                        <span id="marriage-percentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="marriage-progress" style="width: 0%"></div>
                    </div>
                    <small id="marriage-info">0 documents uploaded</small>
                </div>
            </div>

            <div class="stats-overview">
                <h2>üìà Quick Stats</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="total-documents">0</div>
                        <div class="stat-label">Total Documents</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="days-remaining">0</div>
                        <div class="stat-label">Days Remaining</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="current-quarter">Q1</div>
                        <div class="stat-label">Current Quarter</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="quarters-complete">0/8</div>
                        <div class="stat-label">Quarters Complete</div>
                    </div>
                </div>

                <div class="alert alert-info" style="margin-top: 20px;">
                    <span>üíô</span>
                    <span>Every piece of evidence you collect brings you closer to your goal. You're doing amazingly! üè≥Ô∏è‚Äç‚ößÔ∏è</span>
                </div>
                
                <div class="storage-info">
                    <strong>‚ú® Enhanced Storage:</strong> This tracker now uses IndexedDB for unlimited document storage capacity! If you're upgrading from a previous version, your data will be automatically migrated.
                </div>
                
                <p style="text-align: center; color: #666; font-size: 0.9rem; margin-top: 10px;">
                    <em>üí° Tip: Click on any quarter below to manage its evidence documents</em>
                </p>
            </div>
        </div>

        <div class="timeline-section">
            <div class="timeline-header">
                <h2>üìÖ Evidence Timeline (2 Years)</h2>
            </div>
            
            <div class="timeline-grid" id="timeline-grid">
                <!-- Quarters will be generated here -->
            </div>
        </div>

        <div class="categories-section">
            <h2>üìÅ Document Categories</h2>
            <div class="category-tabs">
                <div class="category-tab active" onclick="switchCategory('core')" id="tab-core">
                    <span>üìÑ Core Documents</span>
                    <span class="category-badge" id="badge-core">0/4</span>
                </div>
                <div class="category-tab" onclick="switchCategory('medical')" id="tab-medical">
                    <span>üè• Medical Reports</span>
                    <span class="category-badge" id="badge-medical">0/2</span>
                </div>
                <div class="category-tab" onclick="switchCategory('name')" id="tab-name">
                    <span>üìù Name Change</span>
                    <span class="category-badge" id="badge-name">0</span>
                </div>
                <div class="category-tab" onclick="switchCategory('marriage')" id="tab-marriage">
                    <span>üíç Marriage/Partnership</span>
                    <span class="category-badge" id="badge-marriage">0</span>
                </div>
            </div>

            <div class="category-content active" id="content-core">
                <div class="document-list" id="docs-core">
                    <!-- Core documents will be listed here -->
                </div>
            </div>

            <div class="category-content" id="content-medical">
                <div class="document-list" id="docs-medical">
                    <!-- Medical documents will be listed here -->
                </div>
            </div>

            <div class="category-content" id="content-name">
                <div class="document-list" id="docs-name">
                    <!-- Name change documents will be listed here -->
                </div>
            </div>

            <div class="category-content" id="content-marriage">
                <div class="document-list" id="docs-marriage">
                    <!-- Marriage documents will be listed here -->
                </div>
            </div>
        </div>

        <div class="export-section">
            <h2>üì§ Export & Backup</h2>
            <div class="export-buttons">
                <button class="btn btn-primary" onclick="exportProgress()">
                    <span>üìä</span> Export Progress Report
                </button>
                <button class="btn btn-secondary" onclick="exportBackup()">
                    <span>üíæ</span> Download Full Backup
                </button>
                <button class="btn btn-success" onclick="printChecklist()">
                    <span>üñ®Ô∏è</span> Print Checklist
                </button>
            </div>
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                <h3 style="margin-bottom: 15px;">üì• Import & Restore</h3>
                <div class="export-buttons">
                    <button class="btn btn-primary" onclick="document.getElementById('import-file').click()">
                        <span>üìÇ</span> Import Backup
                    </button>
                    <input type="file" id="import-file" accept=".json" style="display: none;" onchange="importBackup(this)">
                    <button class="btn btn-outline" onclick="clearAllData()">
                        <span>üóëÔ∏è</span> Clear All Data
                    </button>
                </div>
            </div>
        </div>

        <div class="export-section">
            <h2>‚öôÔ∏è Timeline Settings</h2>
            <p style="margin-bottom: 20px; color: #666;">Set your earliest application date (2 years from when you started living in your acquired gender). The evidence collection period will automatically be calculated as the 2 years leading up to this date.</p>
            
            <div style="max-width: 400px; margin: 0 auto;">
                <div style="margin-bottom: 20px;">
                    <label for="target-date" style="display: block; margin-bottom: 8px; font-weight: 500; color: #333;">
                        üéØ Earliest Application Date
                    </label>
                    <input 
                        type="date" 
                        id="target-date" 
                        value="2025-12-01"
                        min="2024-01-01"
                        max="2030-12-31"
                        style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 5px; font-size: 1rem;"
                        onchange="updateTargetDate(this.value)"
                    >
                    <small style="color: #666; display: block; margin-top: 5px;">
                        The earliest date you can submit your GRC application (2 years from when you began living in your acquired gender)
                    </small>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #333;">
                        üìÖ Evidence Collection Period
                    </label>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; border: 1px solid #e0e0e0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>Start:</strong> <span id="calculated-start-date">1 Dec 2023</span>
                            </div>
                            <div style="color: #667eea; font-size: 1.2rem;">‚Üí</div>
                            <div>
                                <strong>End:</strong> <span id="calculated-end-date">1 Dec 2025</span>
                            </div>
                        </div>
                        <div style="text-align: center; margin-top: 10px; color: #666; font-size: 0.9rem;">
                            <span id="timeline-duration">24 months</span> evidence collection
                        </div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <span>üíô</span>
                    <span>The UK's 2-year wait requirement is unjust, but this tracker helps you make the most of that time by organizing your evidence collection. You've got this! üè≥Ô∏è‚Äç‚ößÔ∏è</span>
                </div>
                
                <small style="color: #666; text-align: center; display: block; margin-top: 15px;">
                    <em>Note: Your existing evidence data will be preserved when changing dates. Quarters will be remapped to the new timeline.</em>
                </small>
            </div>
        </div>
    </div>

    <!-- Quarter Modal -->
    <div class="modal" id="quarter-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title">Quarter Evidence</h3>
                <button class="close-modal" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="upload-area" id="upload-area" ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                    <div class="upload-icon">üì§</div>
                    <div class="upload-text">Drop files here or click to upload</div>
                    <div class="upload-subtext">Upload evidence documents for this quarter</div>
                    <input type="file" id="file-input" multiple accept="*/*" style="display: none;" onchange="handleFileSelect(event)">
                </div>

                <div class="file-list" id="file-list">
                    <!-- Files will be listed here -->
                </div>

                <div class="notes-section">
                    <h4>üìù Notes for this quarter</h4>
                    <textarea class="notes-textarea" id="quarter-notes" placeholder="Add any notes about evidence collection for this quarter..."></textarea>
                </div>
            </div>
        </div>
    </div>

    <script>
        // IndexedDB Storage Class - handles all data persistence
        class IndexedDBStorage {
            constructor(dbName = 'GRCTracker', version = 1) {
                this.dbName = dbName;
                this.version = version;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create object stores
                        if (!db.objectStoreNames.contains('metadata')) {
                            db.createObjectStore('metadata', { keyPath: 'key' });
                        }
                        
                        if (!db.objectStoreNames.contains('files')) {
                            const fileStore = db.createObjectStore('files', { keyPath: 'id' });
                            fileStore.createIndex('category', 'category', { unique: false });
                            fileStore.createIndex('quarterId', 'quarterId', { unique: false });
                        }
                    };
                });
            }

            async saveData(data) {
                const transaction = this.db.transaction(['metadata'], 'readwrite');
                const store = transaction.objectStore('metadata');
                
                // Store everything except files in metadata
                const metadataOnly = {
                    quarters: {},
                    documents: {
                        core: {},
                        medical: {},
                        name: {},
                        marriage: {}
                    },
                    notes: data.notes || {},
                    settings: data.settings || { targetDate: '2025-12-01' }
                };

                // Copy quarter data without files
                Object.keys(data.quarters || {}).forEach(quarterId => {
                    metadataOnly.quarters[quarterId] = {
                        notes: data.quarters[quarterId]?.notes || '',
                        fileCount: data.quarters[quarterId]?.files?.length || 0
                    };
                });

                // Copy document data without files
                Object.keys(data.documents || {}).forEach(category => {
                    Object.keys(data.documents[category] || {}).forEach(docId => {
                        metadataOnly.documents[category][docId] = {
                            fileCount: data.documents[category][docId]?.files?.length || 0
                        };
                    });
                });

                await store.put({ key: 'appData', value: metadataOnly });
                return transaction.complete;
            }

            async loadData() {
                const transaction = this.db.transaction(['metadata'], 'readonly');
                const store = transaction.objectStore('metadata');
                const request = store.get('appData');
                
                return new Promise((resolve) => {
                    request.onsuccess = () => {
                        if (request.result) {
                            resolve(request.result.value);
                        } else {
                            // Return default data structure
                            resolve({
                                quarters: {},
                                documents: {
                                    core: {},
                                    medical: {},
                                    name: {},
                                    marriage: {}
                                },
                                notes: {},
                                settings: { targetDate: '2025-12-01' }
                            });
                        }
                    };
                    request.onerror = () => {
                        console.error('Error loading data:', request.error);
                        resolve({
                            quarters: {},
                            documents: {
                                core: {},
                                medical: {},
                                name: {},
                                marriage: {}
                            },
                            notes: {},
                            settings: { targetDate: '2025-12-01' }
                        });
                    };
                });
            }

            async saveFile(fileData) {
                const transaction = this.db.transaction(['files'], 'readwrite');
                const store = transaction.objectStore('files');
                
                const fileRecord = {
                    id: this.generateFileId(),
                    name: fileData.name,
                    size: fileData.size,
                    type: fileData.type,
                    data: fileData.data,
                    uploadDate: fileData.uploadDate,
                    category: fileData.category || null,
                    docId: fileData.docId || null,
                    quarterId: fileData.quarterId || null
                };
                
                await store.put(fileRecord);
                return fileRecord.id;
            }

            async getFiles(filter = {}) {
                const transaction = this.db.transaction(['files'], 'readonly');
                const store = transaction.objectStore('files');
                
                return new Promise((resolve) => {
                    const request = store.getAll();
                    request.onsuccess = () => {
                        let files = request.result;
                        
                        // Apply filters
                        if (filter.quarterId) {
                            files = files.filter(f => f.quarterId === filter.quarterId);
                        }
                        if (filter.category && filter.docId) {
                            files = files.filter(f => f.category === filter.category && f.docId === filter.docId);
                        }
                        
                        resolve(files);
                    };
                    request.onerror = () => {
                        console.error('Error loading files:', request.error);
                        resolve([]);
                    };
                });
            }

            async deleteFile(fileId) {
                const transaction = this.db.transaction(['files'], 'readwrite');
                const store = transaction.objectStore('files');
                await store.delete(fileId);
            }

            async clearAllData() {
                const transaction = this.db.transaction(['metadata', 'files'], 'readwrite');
                const metadataStore = transaction.objectStore('metadata');
                const filesStore = transaction.objectStore('files');
                
                await metadataStore.clear();
                await filesStore.clear();
            }

            generateFileId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            }
        }

        // GRC Tracker Application - Updated to use IndexedDB
        class GRCTracker {
            constructor() {
                this.storage = new IndexedDBStorage();
                this.currentQuarter = null;
                this.currentCategory = 'core';
                this.data = null;
                this.isInitialized = false;
                this.oldStorageKey = 'grc_tracker_v2';
                
                this.init();
            }

            async init() {
                try {
                    await this.storage.init();
                    
                    // Check for and migrate old localStorage data
                    const migrationResult = await this.checkAndMigrateOldData();
                    
                    await this.loadData();
                    this.setupEventHandlers();
                    this.updateDatesFromSettings();
                    await this.render();
                    this.isInitialized = true;
                    
                    // Show migration success message if applicable
                    if (migrationResult.migrated) {
                        this.showMigrationSuccessMessage(migrationResult.stats);
                    }
                } catch (error) {
                    console.error('Failed to initialize GRC Tracker:', error);
                    // Fallback to basic functionality
                    this.initializeFallbackData();
                    this.setupEventHandlers();
                    this.updateDatesFromSettings();
                    this.render();
                }
            }

            async checkAndMigrateOldData() {
                try {
                    // Check if old localStorage data exists
                    const oldDataString = localStorage.getItem(this.oldStorageKey);
                    if (!oldDataString) {
                        return { migrated: false };
                    }

                    console.log('Found old localStorage data, starting migration...');
                    
                    // Parse old data
                    const oldData = JSON.parse(oldDataString);
                    
                    // Show migration confirmation dialog
                    const shouldMigrate = confirm(
                        'üì¶ Data Migration Required\n\n' +
                        'We found data from the previous version of this app. ' +
                        'Would you like to migrate your data to the new improved storage system?\n\n' +
                        '‚úÖ Benefits:\n' +
                        '‚Ä¢ Unlimited document storage\n' +
                        '‚Ä¢ Better performance\n' +
                        '‚Ä¢ No more storage quota errors\n\n' +
                        'Click OK to migrate, or Cancel to start fresh.'
                    );
                    
                    if (!shouldMigrate) {
                        // User chose not to migrate, ask if they want to delete old data
                        const shouldDelete = confirm(
                            'Would you like to delete the old data to free up space?\n\n' +
                            '‚ö†Ô∏è This action cannot be undone.'
                        );
                        
                        if (shouldDelete) {
                            localStorage.removeItem(this.oldStorageKey);
                            alert('‚úÖ Old data deleted successfully.');
                        }
                        
                        return { migrated: false };
                    }

                    // Show migration progress
                    this.showMigrationProgress('Starting migration...');
                    
                    // Migrate the data
                    const migrationStats = await this.migrateData(oldData);
                    
                    // Verify migration success
                    const verificationResult = await this.verifyMigration(oldData, migrationStats);
                    
                    if (verificationResult.success) {
                        // Migration successful, delete old data
                        localStorage.removeItem(this.oldStorageKey);
                        console.log('Migration completed successfully, old data removed');
                        
                        return { 
                            migrated: true, 
                            stats: migrationStats 
                        };
                    } else {
                        throw new Error(`Migration verification failed: ${verificationResult.error}`);
                    }
                    
                } catch (error) {
                    console.error('Migration failed:', error);
                    alert(
                        '‚ùå Migration Failed\n\n' +
                        `Error: ${error.message}\n\n` +
                        'Your old data is still safe in localStorage. ' +
                        'You can try refreshing the page to attempt migration again, ' +
                        'or continue using the app with a fresh start.'
                    );
                    return { migrated: false, error: error.message };
                }
            }

            showMigrationProgress(message) {
                // Create or update migration progress overlay
                let overlay = document.getElementById('migration-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'migration-overlay';
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.8);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10000;
                        color: white;
                        font-family: inherit;
                    `;
                    
                    const content = document.createElement('div');
                    content.style.cssText = `
                        background: #667eea;
                        padding: 30px;
                        border-radius: 10px;
                        text-align: center;
                        max-width: 400px;
                    `;
                    
                    content.innerHTML = `
                        <h3 style="margin-bottom: 20px;">üì¶ Migrating Data</h3>
                        <div class="spinner" style="margin-bottom: 20px;"></div>
                        <p id="migration-message">${message}</p>
                    `;
                    
                    overlay.appendChild(content);
                    document.body.appendChild(overlay);
                } else {
                    document.getElementById('migration-message').textContent = message;
                }
            }

            hideMigrationProgress() {
                const overlay = document.getElementById('migration-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }

            async migrateData(oldData) {
                const stats = {
                    filesConverted: 0,
                    totalFiles: 0,
                    quarters: 0,
                    documents: 0,
                    errors: []
                };

                try {
                    // Migrate settings and basic structure
                    this.showMigrationProgress('Migrating settings...');
                    
                    const newData = {
                        quarters: {},
                        documents: {
                            core: {},
                            medical: {},
                            name: {},
                            marriage: {}
                        },
                        notes: oldData.notes || {},
                        settings: oldData.settings || { targetDate: '2025-12-01' }
                    };

                    // Count total files for progress tracking
                    let totalFileCount = 0;
                    
                    // Count quarter files
                    Object.values(oldData.quarters || {}).forEach(quarter => {
                        if (quarter.files) {
                            totalFileCount += quarter.files.length;
                        }
                    });
                    
                    // Count document files
                    Object.values(oldData.documents || {}).forEach(category => {
                        Object.values(category || {}).forEach(doc => {
                            if (doc.files) {
                                totalFileCount += doc.files.length;
                            }
                        });
                    });
                    
                    stats.totalFiles = totalFileCount;

                    // Migrate quarter data and files
                    this.showMigrationProgress('Migrating quarter evidence...');
                    
                    for (const [quarterId, quarterData] of Object.entries(oldData.quarters || {})) {
                        newData.quarters[quarterId] = {
                            notes: quarterData.notes || '',
                            fileCount: 0
                        };

                        if (quarterData.files && quarterData.files.length > 0) {
                            for (const file of quarterData.files) {
                                try {
                                    // Convert base64 data URL to binary
                                    const binaryData = this.dataURLToArrayBuffer(file.data);
                                    
                                    // Save to IndexedDB
                                    await this.storage.saveFile({
                                        name: file.name,
                                        size: file.size,
                                        type: file.type,
                                        data: binaryData,
                                        uploadDate: file.uploadDate,
                                        quarterId: quarterId
                                    });
                                    
                                    newData.quarters[quarterId].fileCount++;
                                    stats.filesConverted++;
                                    
                                    this.showMigrationProgress(`Converting files... ${stats.filesConverted}/${stats.totalFiles}`);
                                } catch (error) {
                                    console.error(`Error migrating quarter file: ${file.name}`, error);
                                    stats.errors.push(`Quarter file ${file.name}: ${error.message}`);
                                }
                            }
                        }
                        
                        stats.quarters++;
                    }

                    // Migrate document category files
                    this.showMigrationProgress('Migrating document categories...');
                    
                    for (const [category, categoryData] of Object.entries(oldData.documents || {})) {
                        for (const [docId, docData] of Object.entries(categoryData || {})) {
                            newData.documents[category][docId] = {
                                fileCount: 0
                            };

                            if (docData.files && docData.files.length > 0) {
                                for (const file of docData.files) {
                                    try {
                                        // Convert base64 data URL to binary
                                        const binaryData = this.dataURLToArrayBuffer(file.data);
                                        
                                        // Save to IndexedDB
                                        await this.storage.saveFile({
                                            name: file.name,
                                            size: file.size,
                                            type: file.type,
                                            data: binaryData,
                                            uploadDate: file.uploadDate,
                                            category: category,
                                            docId: docId
                                        });
                                        
                                        newData.documents[category][docId].fileCount++;
                                        stats.filesConverted++;
                                        stats.documents++;
                                        
                                        this.showMigrationProgress(`Converting files... ${stats.filesConverted}/${stats.totalFiles}`);
                                    } catch (error) {
                                        console.error(`Error migrating document file: ${file.name}`, error);
                                        stats.errors.push(`Document file ${file.name}: ${error.message}`);
                                    }
                                }
                            }
                        }
                    }

                    // Save migrated metadata
                    this.showMigrationProgress('Finalizing migration...');
                    await this.storage.saveData(newData);
                    
                    this.hideMigrationProgress();
                    return stats;
                    
                } catch (error) {
                    this.hideMigrationProgress();
                    throw new Error(`Migration failed: ${error.message}`);
                }
            }

            dataURLToArrayBuffer(dataURL) {
                // Remove data URL prefix (e.g., "data:image/jpeg;base64,")
                const base64String = dataURL.split(',')[1];
                
                // Convert base64 to binary
                const binaryString = atob(base64String);
                const bytes = new Uint8Array(binaryString.length);
                
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                return bytes.buffer;
            }

            async verifyMigration(oldData, migrationStats) {
                try {
                    // Load the migrated data
                    const newData = await this.storage.loadData();
                    const allFiles = await this.storage.getFiles();
                    
                    // Verify file counts match
                    const expectedFileCount = migrationStats.totalFiles;
                    const actualFileCount = allFiles.length;
                    
                    if (actualFileCount !== migrationStats.filesConverted) {
                        return {
                            success: false,
                            error: `File count mismatch: expected ${migrationStats.filesConverted}, got ${actualFileCount}`
                        };
                    }
                    
                    // Verify settings were preserved
                    if (!newData.settings || !newData.settings.targetDate) {
                        return {
                            success: false,
                            error: 'Settings not properly migrated'
                        };
                    }
                    
                    // Verify quarter structure
                    const oldQuarterCount = Object.keys(oldData.quarters || {}).length;
                    const newQuarterCount = Object.keys(newData.quarters || {}).length;
                    
                    if (oldQuarterCount !== newQuarterCount) {
                        return {
                            success: false,
                            error: `Quarter count mismatch: expected ${oldQuarterCount}, got ${newQuarterCount}`
                        };
                    }
                    
                    return { success: true };
                    
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            showMigrationSuccessMessage(stats) {
                const hasErrors = stats.errors.length > 0;
                const message = hasErrors 
                    ? `üéâ Migration Completed!\n\n‚úÖ Successfully migrated:\n‚Ä¢ ${stats.filesConverted} files\n‚Ä¢ ${stats.quarters} quarters\n‚Ä¢ Document categories\n\n‚ö†Ô∏è ${stats.errors.length} files had issues:\n${stats.errors.slice(0, 3).join('\n')}${stats.errors.length > 3 ? '\n...' : ''}\n\nYour app now has unlimited storage capacity!`
                    : `üéâ Migration Completed Successfully!\n\n‚úÖ Migrated:\n‚Ä¢ ${stats.filesConverted} files\n‚Ä¢ ${stats.quarters} quarters\n‚Ä¢ All document categories\n\nYour app now has unlimited storage capacity!\nNo more "quota exceeded" errors! üöÄ`;
                
                setTimeout(() => {
                    alert(message);
                }, 1000);
            }

            async loadData() {
                this.data = await this.storage.loadData();
                
                // Ensure data structure is complete
                if (!this.data.settings) {
                    this.data.settings = { targetDate: '2025-12-01' };
                }
                if (!this.data.settings.targetDate) {
                    this.data.settings.targetDate = '2025-12-01';
                }
            }

            initializeFallbackData() {
                this.data = {
                    quarters: {},
                    documents: {
                        core: {},
                        medical: {},
                        name: {},
                        marriage: {}
                    },
                    notes: {},
                    settings: { targetDate: '2025-12-01' }
                };
            }

            async saveData() {
                if (this.storage) {
                    try {
                        await this.storage.saveData(this.data);
                    } catch (error) {
                        console.error('Error saving data:', error);
                    }
                }
            }

            setupEventHandlers() {
                // Upload area
                const uploadArea = document.getElementById('upload-area');
                if (uploadArea) {
                    uploadArea.onclick = () => document.getElementById('file-input').click();
                }

                // Quarter notes auto-save
                const notesTextarea = document.getElementById('quarter-notes');
                if (notesTextarea) {
                    notesTextarea.addEventListener('input', (e) => {
                        clearTimeout(this.autoSaveTimer);
                        this.autoSaveTimer = setTimeout(() => {
                            this.saveQuarterNotes(e.target.value);
                        }, 1000);
                    });
                }
            }

            updateDatesFromSettings() {
                // Calculate start date as 2 years before target date
                this.targetDate = new Date(this.data.settings.targetDate);
                this.startDate = new Date(this.targetDate);
                this.startDate.setFullYear(this.startDate.getFullYear() - 2);
                
                // Update UI
                this.updateDateDisplay();
            }

            updateDateDisplay() {
                const targetInput = document.getElementById('target-date');
                const startSpan = document.getElementById('calculated-start-date');
                const endSpan = document.getElementById('calculated-end-date');
                const durationSpan = document.getElementById('timeline-duration');
                
                if (targetInput) {
                    targetInput.value = this.data.settings.targetDate;
                }
                
                if (startSpan) {
                    startSpan.textContent = this.formatDate(this.startDate);
                }
                
                if (endSpan) {
                    endSpan.textContent = this.formatDate(this.targetDate);
                }
                
                if (durationSpan) {
                    const months = Math.round((this.targetDate - this.startDate) / (1000 * 60 * 60 * 24 * 30.44));
                    durationSpan.textContent = `${months} months`;
                }
            }

            async updateTargetDate(dateString) {
                // Validate date
                const newDate = new Date(dateString);
                const minDate = new Date('2024-01-01');
                const maxDate = new Date('2030-12-31');
                
                if (newDate < minDate || newDate > maxDate) {
                    alert('Please select a date between 2024 and 2030');
                    document.getElementById('target-date').value = this.data.settings.targetDate;
                    return;
                }
                
                // Update settings
                this.data.settings.targetDate = dateString;
                await this.saveData();
                
                // Recalculate dates and update display
                this.updateDatesFromSettings();
                await this.render();
            }

            async render() {
                await this.updateProgress();
                await this.updateStats();
                await this.renderTimeline();
                await this.renderDocuments();
                await this.updateCategoryBadges();
                this.updateDateDisplay();
            }

            // Document definitions
            get documentDefs() {
                return {
                    core: [
                        {
                            id: 'birth-certificate',
                            title: 'Birth/Adoption Certificate',
                            description: 'Original or certified copy of your full birth or adoption certificate',
                            required: true
                        },
                        {
                            id: 'statutory-declaration',
                            title: 'Statutory Declaration',
                            description: 'Signed declaration that your gender change is permanent',
                            required: true
                        },
                        {
                            id: 'application-form',
                            title: 'Application Form',
                            description: 'Completed GRC application form from gov.uk',
                            required: true
                        },
                        {
                            id: 'application-fee',
                            title: 'Application Fee Receipt',
                            description: 'Proof of ¬£5 fee payment (or fee waiver)',
                            required: true
                        }
                    ],
                    medical: [
                        {
                            id: 'specialist-report',
                            title: 'Specialist Medical Report',
                            description: 'Report from registered medical practitioner specialising in gender dysphoria confirming diagnosis',
                            required: true
                        },
                        {
                            id: 'second-report',
                            title: 'Second Medical Report',
                            description: 'Report from any registered medical practitioner detailing treatment (can be your GP)',
                            required: true
                        }
                    ],
                    name: [
                        {
                            id: 'deed-poll',
                            title: 'Deed Poll',
                            description: 'Enrolled or unenrolled deed poll for name change',
                            required: false
                        },
                        {
                            id: 'statutory-declaration-name',
                            title: 'Statutory Declaration of Name Change',
                            description: 'Alternative to deed poll',
                            required: false
                        }
                    ],
                    marriage: [
                        {
                            id: 'spouse-declaration',
                            title: 'Spouse Statutory Declaration',
                            description: 'Spouse\'s consent to remain married (required if married/partnered)',
                            required: true
                        },
                        {
                            id: 'marriage-certificate',
                            title: 'Marriage Certificate',
                            description: 'Certificate of current marriage',
                            required: false
                        },
                        {
                            id: 'civil-partnership-certificate',
                            title: 'Civil Partnership Certificate',
                            description: 'Certificate of current civil partnership',
                            required: false
                        }
                    ]
                };
            }

            // Quarter management
            getQuarters() {
                const quarters = [];
                let current = new Date(this.startDate);
                let id = 1;
                
                while (current < this.targetDate) {
                    const end = new Date(current);
                    end.setMonth(current.getMonth() + 3);
                    
                    quarters.push({
                        id: `q${id}`,
                        name: `Q${Math.ceil((current.getMonth() + 1) / 3)} ${current.getFullYear()}`,
                        start: new Date(current),
                        end: new Date(end)
                    });
                    
                    current = end;
                    id++;
                }
                
                return quarters;
            }

            getCurrentQuarterInfo() {
                const now = new Date();
                const quarters = this.getQuarters();
                return quarters.find(q => now >= q.start && now < q.end) || quarters[0];
            }

            isCurrentQuarter(quarter) {
                const now = new Date();
                return now >= quarter.start && now < quarter.end;
            }

            async isQuarterComplete(quarter) {
                const count = await this.getQuarterEvidenceCount(quarter.id);
                return count >= 2;
            }

            async getQuarterEvidenceCount(quarterId) {
                if (!this.storage) return this.data.quarters[quarterId]?.fileCount || 0;
                
                const files = await this.storage.getFiles({ quarterId });
                return files.length;
            }

            async getTotalEvidenceCount() {
                if (!this.storage) {
                    return Object.values(this.data.quarters).reduce((total, quarter) => {
                        return total + (quarter.fileCount || 0);
                    }, 0);
                }
                
                const files = await this.storage.getFiles();
                return files.filter(f => f.quarterId).length;
            }

            // Document management
            async hasDocument(category, docId) {
                if (!this.storage) return !!(this.data.documents[category][docId]?.fileCount);
                
                const files = await this.storage.getFiles({ category, docId });
                return files.length > 0;
            }

            async getDocumentFiles(category, docId) {
                if (!this.storage) return [];
                
                return await this.storage.getFiles({ category, docId });
            }

            async getTotalDocumentCount() {
                if (!this.storage) {
                    let count = 0;
                    
                    // Count category documents
                    Object.keys(this.data.documents).forEach(category => {
                        Object.values(this.data.documents[category]).forEach(doc => {
                            count += doc.fileCount || 0;
                        });
                    });
                    
                    // Count quarter evidence
                    Object.values(this.data.quarters).forEach(quarter => {
                        count += quarter.fileCount || 0;
                    });
                    
                    return count;
                }
                
                const files = await this.storage.getFiles();
                return files.length;
            }

            // Time remaining calculation
            calculateTimeRemaining() {
                const now = new Date();
                const diffMs = this.targetDate - now;
                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                
                if (diffDays < 0) {
                    // Past application date - celebrate being eligible!
                    const eligibleDays = Math.abs(diffDays);
                    if (eligibleDays === 1) {
                        return { text: 'üéâ Eligible to apply! (1 day past wait period)', eligible: true };
                    } else if (eligibleDays < 30) {
                        return { text: `üéâ Eligible to apply! (${eligibleDays} days past wait period)`, eligible: true };
                    } else if (eligibleDays < 365) {
                        const eligibleMonths = Math.floor(eligibleDays / 30.44);
                        const remainingDays = Math.floor(eligibleDays % 30.44);
                        if (eligibleMonths === 1 && remainingDays === 0) {
                            return { text: 'üéâ Eligible to apply! (1 month past wait period)', eligible: true };
                        } else if (eligibleMonths === 1) {
                            return { text: `üéâ Eligible to apply! (1 month, ${remainingDays} days past wait period)`, eligible: true };
                        } else if (remainingDays === 0) {
                            return { text: `üéâ Eligible to apply! (${eligibleMonths} months past wait period)`, eligible: true };
                        } else {
                            return { text: `üéâ Eligible to apply! (${eligibleMonths} months, ${remainingDays} days past wait period)`, eligible: true };
                        }
                    } else {
                        const eligibleYears = Math.floor(eligibleDays / 365.25);
                        const remainingMonths = Math.floor((eligibleDays % 365.25) / 30.44);
                        if (eligibleYears === 1 && remainingMonths === 0) {
                            return { text: 'üéâ Eligible to apply! (1 year past wait period)', eligible: true };
                        } else if (eligibleYears === 1) {
                            return { text: `üéâ Eligible to apply! (1 year, ${remainingMonths} months past wait period)`, eligible: true };
                        } else if (remainingMonths === 0) {
                            return { text: `üéâ Eligible to apply! (${eligibleYears} years past wait period)`, eligible: true };
                        } else {
                            return { text: `üéâ Eligible to apply! (${eligibleYears} years, ${remainingMonths} months past wait period)`, eligible: true };
                        }
                    }
                } else if (diffDays === 0) {
                    return { text: 'üéâ Wait period ends today - you can apply!', eligible: true };
                } else if (diffDays === 1) {
                    return { text: '1 day left in mandatory wait period', urgent: true };
                } else if (diffDays < 30) {
                    return { text: `${diffDays} days left in mandatory wait period`, urgent: diffDays <= 7 };
                } else if (diffDays < 365) {
                    const months = Math.floor(diffDays / 30.44);
                    const remainingDays = Math.floor(diffDays % 30.44);
                    if (months === 1 && remainingDays === 0) {
                        return { text: '1 month left in mandatory wait period', urgent: false };
                    } else if (months === 1) {
                        return { text: `1 month, ${remainingDays} days left in mandatory wait period`, urgent: false };
                    } else if (remainingDays === 0) {
                        return { text: `${months} months left in mandatory wait period`, urgent: false };
                    } else {
                        return { text: `${months} months, ${remainingDays} days left in mandatory wait period`, urgent: false };
                    }
                } else {
                    const years = Math.floor(diffDays / 365.25);
                    const remainingMonths = Math.floor((diffDays % 365.25) / 30.44);
                    if (years === 1 && remainingMonths === 0) {
                        return { text: '1 year left in mandatory wait period', urgent: false };
                    } else if (years === 1) {
                        return { text: `1 year, ${remainingMonths} months left in mandatory wait period`, urgent: false };
                    } else if (remainingMonths === 0) {
                        return { text: `${years} years left in mandatory wait period`, urgent: false };
                    } else {
                        return { text: `${years} years, ${remainingMonths} months left in mandatory wait period`, urgent: false };
                    }
                }
            }

            async updateProgress() {
                // Timeline progress
                const now = new Date();
                const totalDays = (this.targetDate - this.startDate) / (1000 * 60 * 60 * 24);
                const elapsedDays = (now - this.startDate) / (1000 * 60 * 60 * 24);
                const timelineProgress = Math.min(100, Math.max(0, (elapsedDays / totalDays) * 100));
                
                // Calculate time remaining
                const timeRemaining = this.calculateTimeRemaining();
                
                const progressBar = document.getElementById('timeline-progress');
                progressBar.style.width = `${timelineProgress}%`;
                
                // Update progress bar styling based on urgency
                progressBar.classList.remove('overdue', 'danger', 'warning', 'eligible');
                if (timeRemaining.eligible) {
                    progressBar.classList.add('eligible');
                } else if (timeRemaining.urgent) {
                    progressBar.classList.add('danger');
                } else if (timelineProgress > 75) {
                    progressBar.classList.add('warning');
                }
                
                document.getElementById('timeline-countdown').textContent = timeRemaining.text;
                document.getElementById('timeline-info').textContent = 
                    `Evidence collection: ${this.formatDate(this.startDate)} ‚Üí ${this.formatDate(this.targetDate)}`;

                // Update the label based on eligibility status
                const timelineLabel = document.querySelector('.progress-item .progress-label span:first-child');
                if (timelineLabel) {
                    if (timeRemaining.eligible) {
                        timelineLabel.textContent = 'üéâ Application Eligibility';
                    } else {
                        timelineLabel.textContent = 'Time Until Eligible';
                    }
                }

                // Update progress overview title
                const progressTitle = document.getElementById('progress-overview-title');
                if (progressTitle && timeRemaining.eligible) {
                    progressTitle.innerHTML = 'üéâ Overall Progress - You\'re Eligible!';
                } else if (progressTitle) {
                    progressTitle.innerHTML = 'üìä Overall Progress';
                }

                // Core documents progress
                const coreTotal = this.documentDefs.core.filter(d => d.required).length;
                let coreComplete = 0;
                for (const doc of this.documentDefs.core.filter(d => d.required)) {
                    if (await this.hasDocument('core', doc.id)) coreComplete++;
                }
                const coreProgress = coreTotal > 0 ? (coreComplete / coreTotal) * 100 : 0;
                
                document.getElementById('core-progress').style.width = `${coreProgress}%`;
                document.getElementById('core-percentage').textContent = `${coreProgress.toFixed(0)}%`;
                document.getElementById('core-info').textContent = `${coreComplete} of ${coreTotal} required documents`;

                // Medical reports progress
                const medicalTotal = 2;
                let medicalComplete = 0;
                for (const doc of this.documentDefs.medical) {
                    if (await this.hasDocument('medical', doc.id)) medicalComplete++;
                }
                const medicalProgress = (medicalComplete / medicalTotal) * 100;
                
                document.getElementById('medical-progress').style.width = `${medicalProgress}%`;
                document.getElementById('medical-percentage').textContent = `${medicalProgress.toFixed(0)}%`;
                document.getElementById('medical-info').textContent = `${medicalComplete} of ${medicalTotal} reports`;

                // Evidence progress
                const evidenceTarget = 16; // 8 quarters * 2 pieces
                const evidenceCount = await this.getTotalEvidenceCount();
                const evidenceProgress = Math.min(100, (evidenceCount / evidenceTarget) * 100);
                
                document.getElementById('evidence-progress').style.width = `${evidenceProgress}%`;
                document.getElementById('evidence-percentage').textContent = `${evidenceProgress.toFixed(0)}%`;
                document.getElementById('evidence-info').textContent = `${evidenceCount} pieces collected (target: ${evidenceTarget})`;

                // Name change progress
                let nameComplete = 0;
                for (const doc of this.documentDefs.name) {
                    if (await this.hasDocument('name', doc.id)) {
                        nameComplete++;
                        break; // Any document counts as complete
                    }
                }
                const nameProgress = nameComplete > 0 ? 100 : 0;
                
                document.getElementById('name-progress').style.width = `${nameProgress}%`;
                document.getElementById('name-percentage').textContent = `${nameProgress}%`;
                document.getElementById('name-info').textContent = nameComplete > 0 ? 
                    `‚úì Name change documented` : `No name change documents`;

                // Marriage/Partnership progress
                const marriageProgress = await this.getMarriageProgress();
                
                document.getElementById('marriage-progress').style.width = `${marriageProgress.percentage}%`;
                document.getElementById('marriage-percentage').textContent = `${marriageProgress.percentage}%`;
                document.getElementById('marriage-info').textContent = marriageProgress.info;

                // Calculate master progress
                await this.updateMasterProgress({
                    timeline: timelineProgress,
                    core: coreProgress,
                    medical: medicalProgress,
                    evidence: evidenceProgress,
                    name: nameProgress,
                    marriage: marriageProgress.percentage,
                    coreComplete,
                    coreTotal,
                    medicalComplete,
                    medicalTotal,
                    evidenceCount,
                    evidenceTarget,
                    nameComplete: nameComplete > 0 ? 1 : 0,
                    marriageComplete: marriageProgress.complete ? 1 : 0
                });
            }

            async getMarriageProgress() {
                const hasSpouseDeclaration = await this.hasDocument('marriage', 'spouse-declaration');
                const hasMarriageCert = await this.hasDocument('marriage', 'marriage-certificate');
                const hasCivilPartnershipCert = await this.hasDocument('marriage', 'civil-partnership-certificate');
                
                const hasRequiredCertificate = hasMarriageCert || hasCivilPartnershipCert;
                const isComplete = hasSpouseDeclaration && hasRequiredCertificate;
                
                let info = '';
                if (isComplete) {
                    info = '‚úì Marriage/partnership documented';
                } else if (hasSpouseDeclaration && !hasRequiredCertificate) {
                    info = 'Need marriage or civil partnership certificate';
                } else if (!hasSpouseDeclaration && hasRequiredCertificate) {
                    info = 'Need spouse statutory declaration';
                } else {
                    info = 'No marriage/partnership documents';
                }
                
                return {
                    percentage: isComplete ? 100 : 0,
                    complete: isComplete,
                    info: info
                };
            }

            async updateMasterProgress(progressData) {
                // Calculate weighted master progress
                const requiredProgress = (progressData.core * 0.2) + (progressData.medical * 0.2) + (progressData.evidence * 0.4);
                const timelineWeight = progressData.timeline * 0.1;
                const optionalProgress = Math.max(progressData.name, progressData.marriage) * 0.1;
                
                const masterProgress = requiredProgress + timelineWeight + optionalProgress;
                
                document.getElementById('master-progress').style.width = `${masterProgress}%`;
                document.getElementById('master-progress-text').textContent = `${masterProgress.toFixed(0)}%`;
                
                // Update details
                const totalRequired = progressData.coreTotal + progressData.medicalTotal + progressData.evidenceTarget;
                const totalComplete = progressData.coreComplete + progressData.medicalComplete + progressData.evidenceCount;
                const nameStatus = progressData.nameComplete > 0 ? 1 : 0;
                const optionalDocs = nameStatus + progressData.marriageComplete;
                
                const quarters = this.getQuarters();
                let completeQuarters = 0;
                for (const quarter of quarters) {
                    if (await this.isQuarterComplete(quarter)) completeQuarters++;
                }
                
                document.getElementById('master-progress-details').innerHTML = `
                    <strong>${totalComplete}</strong> of <strong>${totalRequired}</strong> required items completed
                    ${optionalDocs > 0 ? ` ‚Ä¢ <strong>${optionalDocs}</strong> optional categories completed` : ''}
                    ‚Ä¢ ${completeQuarters} of 8 quarters complete
                `;
            }

            async updateStats() {
                // Total documents
                const totalDocs = await this.getTotalDocumentCount();
                document.getElementById('total-documents').textContent = totalDocs;

                // Days remaining/eligible
                const now = new Date();
                const daysRemaining = Math.ceil((this.targetDate - now) / (1000 * 60 * 60 * 24));
                const timeRemaining = this.calculateTimeRemaining();
                
                const daysElement = document.getElementById('days-remaining');
                const daysLabelElement = daysElement.nextElementSibling;
                
                if (timeRemaining.eligible) {
                    daysElement.textContent = Math.abs(daysRemaining);
                    daysLabelElement.textContent = 'Days Eligible';
                    daysElement.style.color = '#28a745';
                } else {
                    daysElement.textContent = Math.max(0, daysRemaining);
                    daysLabelElement.textContent = 'Days Until Eligible';
                    daysElement.style.color = '#667eea';
                }

                // Current quarter
                const currentQuarter = this.getCurrentQuarterInfo();
                document.getElementById('current-quarter').textContent = currentQuarter.name;

                // Quarters complete
                const quarters = this.getQuarters();
                let completeQuarters = 0;
                for (const quarter of quarters) {
                    if (await this.isQuarterComplete(quarter)) completeQuarters++;
                }
                document.getElementById('quarters-complete').textContent = `${completeQuarters}/8`;
            }

            async renderTimeline() {
                const container = document.getElementById('timeline-grid');
                const quarters = this.getQuarters();
                
                const quarterElements = await Promise.all(quarters.map(async (quarter) => {
                    const evidenceCount = await this.getQuarterEvidenceCount(quarter.id);
                    const isComplete = evidenceCount >= 2;
                    const isCurrent = this.isCurrentQuarter(quarter);
                    const isFuture = new Date() < quarter.start;
                    
                    let statusClass = '';
                    let statusIcon = '‚è≥';
                    
                    if (isComplete) {
                        statusClass = 'completed';
                        statusIcon = '‚úÖ';
                    } else if (isCurrent) {
                        statusClass = 'current';
                        statusIcon = 'üìç';
                    } else if (isFuture) {
                        statusClass = 'future';
                        statusIcon = 'üîÆ';
                    }
                    
                    const progress = Math.min(100, (evidenceCount / 2) * 100);
                    
                    return `
                        <div class="quarter-card ${statusClass}" onclick="openQuarterModal('${quarter.id}')">
                            <div class="quarter-header">
                                <div class="quarter-title">${quarter.name}</div>
                                <div class="quarter-status">${statusIcon}</div>
                            </div>
                            <div class="quarter-dates">${this.formatDate(quarter.start)} - ${this.formatDate(quarter.end)}</div>
                            <div class="quarter-progress">
                                <div class="mini-progress-bar">
                                    <div class="mini-progress-fill" style="width: ${progress}%"></div>
                                </div>
                            </div>
                            <div class="quarter-stats">
                                <span>${evidenceCount}/2 documents</span>
                                <span>${progress.toFixed(0)}%</span>
                            </div>
                            <div class="quarter-action">Click to manage evidence ‚Üí</div>
                        </div>
                    `;
                }));
                
                container.innerHTML = quarterElements.join('');
            }

            async renderDocuments() {
                for (const category of ['core', 'medical', 'name', 'marriage']) {
                    const container = document.getElementById(`docs-${category}`);
                    const docs = this.documentDefs[category];
                    
                    const docElements = await Promise.all(docs.map(async (doc) => {
                        const hasDoc = await this.hasDocument(category, doc.id);
                        const files = await this.getDocumentFiles(category, doc.id);
                        const statusClass = hasDoc ? 'completed' : (doc.required ? 'required' : '');
                        const statusText = hasDoc ? 'Completed' : (doc.required ? 'Required' : 'Optional');
                        const statusIcon = hasDoc ? '‚úÖ' : (doc.required ? '‚ö†Ô∏è' : 'üìã');
                        
                        return `
                            <div class="document-item ${statusClass}">
                                <div class="document-header">
                                    <div class="document-title">${doc.title}</div>
                                    <div class="document-status ${statusClass}">
                                        <span>${statusIcon}</span>
                                        <span>${statusText}</span>
                                    </div>
                                </div>
                                <div class="document-description">${doc.description}</div>
                                <div class="document-actions">
                                    <button class="btn btn-primary" onclick="uploadCategoryDocument('${category}', '${doc.id}')">
                                        <span>üì§</span> Upload
                                    </button>
                                    ${files.length > 0 ? `
                                        <button class="btn btn-success" onclick="viewDocumentFiles('${category}', '${doc.id}')">
                                            <span>üëÅÔ∏è</span> View (${files.length})
                                        </button>
                                        <button class="btn btn-danger" onclick="deleteCategoryDocument('${category}', '${doc.id}')">
                                            <span>üóëÔ∏è</span> Delete
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                    }));
                    
                    container.innerHTML = docElements.join('');
                }
            }

            async updateCategoryBadges() {
                const categories = ['core', 'medical', 'name', 'marriage'];
                
                for (const category of categories) {
                    const badge = document.getElementById(`badge-${category}`);
                    if (badge) {
                        if (category === 'core' || category === 'medical') {
                            let completed = 0;
                            for (const doc of this.documentDefs[category].filter(d => d.required)) {
                                if (await this.hasDocument(category, doc.id)) completed++;
                            }
                            const total = this.documentDefs[category].filter(d => d.required).length;
                            badge.textContent = `${completed}/${total}`;
                        } else if (category === 'name') {
                            let completed = 0;
                            for (const doc of this.documentDefs[category]) {
                                if (await this.hasDocument(category, doc.id)) {
                                    completed++;
                                    break;
                                }
                            }
                            badge.textContent = completed > 0 ? '‚úì' : '0';
                        } else if (category === 'marriage') {
                            const marriageProgress = await this.getMarriageProgress();
                            badge.textContent = marriageProgress.complete ? '‚úì' : '0';
                        }
                    }
                }
            }

            // File handling with IndexedDB
            async handleFileUpload(files) {
                if (!this.currentQuarter) return;
                
                if (!this.data.quarters[this.currentQuarter]) {
                    this.data.quarters[this.currentQuarter] = { notes: '', fileCount: 0 };
                }
                
                const quarterData = this.data.quarters[this.currentQuarter];
                
                for (const file of Array.from(files)) {
                    try {
                        const arrayBuffer = await this.readFileAsArrayBuffer(file);
                        
                        if (this.storage) {
                            await this.storage.saveFile({
                                name: file.name,
                                size: file.size,
                                type: file.type,
                                data: arrayBuffer,
                                uploadDate: new Date().toISOString(),
                                quarterId: this.currentQuarter
                            });
                        }
                        
                        quarterData.fileCount = (quarterData.fileCount || 0) + 1;
                    } catch (error) {
                        console.error('Error uploading file:', error);
                        alert(`Error uploading ${file.name}: ${error.message}`);
                    }
                }
                
                await this.saveData();
                await this.render();
                await this.renderQuarterFiles();
            }

            readFileAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(new Error('Failed to read file'));
                    reader.readAsArrayBuffer(file);
                });
            }

            async renderQuarterFiles() {
                if (!this.currentQuarter) return;
                
                const container = document.getElementById('file-list');
                
                if (!this.storage) {
                    container.innerHTML = '<p style="text-align: center; color: #666; margin-top: 20px;">Storage not available</p>';
                    return;
                }
                
                const files = await this.storage.getFiles({ quarterId: this.currentQuarter });
                
                if (files.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; margin-top: 20px;">No files uploaded yet</p>';
                    return;
                }
                
                container.innerHTML = '<h4>üìÅ Uploaded Evidence</h4>' + 
                    files.map((file, index) => `
                        <div class="file-item">
                            <div class="file-info">
                                <div class="file-icon">üìÑ</div>
                                <div class="file-details">
                                    <div class="file-name">${file.name}</div>
                                    <div class="file-meta">
                                        ${this.formatFileSize(file.size)} ‚Ä¢ Uploaded ${this.formatDate(new Date(file.uploadDate))}
                                    </div>
                                </div>
                            </div>
                            <div class="file-actions">
                                <button class="btn btn-success" onclick="tracker.downloadFile('${file.id}')">
                                    Download
                                </button>
                                <button class="btn btn-danger" onclick="tracker.deleteFile('${file.id}')">
                                    Delete
                                </button>
                            </div>
                        </div>
                    `).join('');
            }

            async downloadFile(fileId) {
                if (!this.storage) return;
                
                const files = await this.storage.getFiles();
                const file = files.find(f => f.id === fileId);
                if (!file) return;
                
                const blob = new Blob([file.data], { type: file.type });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = file.name;
                link.click();
                URL.revokeObjectURL(url);
            }

            async deleteFile(fileId) {
                if (!confirm('Are you sure you want to delete this file?')) return;
                
                if (!this.storage) return;
                
                // Get file details before deleting
                const files = await this.storage.getFiles();
                const file = files.find(f => f.id === fileId);
                if (!file) return;
                
                await this.storage.deleteFile(fileId);
                
                // Update counters
                if (file.quarterId && this.data.quarters[file.quarterId]) {
                    this.data.quarters[file.quarterId].fileCount = Math.max(0, 
                        (this.data.quarters[file.quarterId].fileCount || 1) - 1);
                }
                
                if (file.category && file.docId && this.data.documents[file.category][file.docId]) {
                    this.data.documents[file.category][file.docId].fileCount = Math.max(0,
                        (this.data.documents[file.category][file.docId].fileCount || 1) - 1);
                }
                
                await this.saveData();
                await this.render();
                if (this.currentQuarter) {
                    await this.renderQuarterFiles();
                }
            }

            async saveQuarterNotes(notes) {
                if (!this.currentQuarter) return;
                
                if (!this.data.quarters[this.currentQuarter]) {
                    this.data.quarters[this.currentQuarter] = { notes: '', fileCount: 0 };
                }
                
                this.data.quarters[this.currentQuarter].notes = notes;
                await this.saveData();
            }

            // Utility functions
            formatDate(date) {
                return date.toLocaleDateString('en-GB', { 
                    day: 'numeric', 
                    month: 'short', 
                    year: 'numeric' 
                });
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            // Export functions (updated for IndexedDB)
            async exportProgress() {
                const quarters = this.getQuarters();
                let completeQuarters = 0;
                for (const quarter of quarters) {
                    if (await this.isQuarterComplete(quarter)) completeQuarters++;
                }
                
                const report = {
                    exportDate: new Date().toISOString(),
                    timeline: {
                        startDate: this.startDate.toISOString(),
                        targetDate: this.targetDate.toISOString(),
                        customTargetDate: this.data.settings.targetDate,
                        timeRemaining: this.calculateTimeRemaining()
                    },
                    summary: {
                        totalDocuments: await this.getTotalDocumentCount(),
                        evidenceCount: await this.getTotalEvidenceCount(),
                        quartersComplete: completeQuarters
                    },
                    quarters: {},
                    documents: {}
                };

                // Add quarter summaries
                for (const quarter of quarters) {
                    report.quarters[quarter.id] = {
                        name: quarter.name,
                        dateRange: `${this.formatDate(quarter.start)} - ${this.formatDate(quarter.end)}`,
                        evidenceCount: await this.getQuarterEvidenceCount(quarter.id),
                        isComplete: await this.isQuarterComplete(quarter)
                    };
                }

                // Add document summaries
                for (const category of Object.keys(this.documentDefs)) {
                    report.documents[category] = await Promise.all(
                        this.documentDefs[category].map(async (doc) => ({
                            title: doc.title,
                            required: doc.required,
                            uploaded: await this.hasDocument(category, doc.id)
                        }))
                    );
                }

                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `grc-progress-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }

            async exportBackup() {
                // Create a simplified backup without actual file data
                const backupData = {
                    ...this.data,
                    _backupNote: 'This backup contains metadata only. File data is not included due to size limitations.'
                };
                
                const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `grc-backup-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }

            async printChecklist() {
                const printWindow = window.open('', '_blank');
                const quarters = this.getQuarters();
                const timeRemaining = this.calculateTimeRemaining();
                
                let quartersHtml = '';
                for (const q of quarters) {
                    const isComplete = await this.isQuarterComplete(q);
                    const evidenceCount = await this.getQuarterEvidenceCount(q.id);
                    quartersHtml += `
                        <div class="item ${isComplete ? 'completed' : ''}">
                            <strong>${q.name}</strong> (${this.formatDate(q.start)} - ${this.formatDate(q.end)})<br>
                            Evidence: ${evidenceCount}/2 pieces
                        </div>
                    `;
                }
                
                let documentsHtml = '';
                for (const category of Object.keys(this.documentDefs)) {
                    documentsHtml += `<h3>${category.charAt(0).toUpperCase() + category.slice(1)} Documents</h3>`;
                    for (const doc of this.documentDefs[category]) {
                        const hasDoc = await this.hasDocument(category, doc.id);
                        documentsHtml += `
                            <div class="item ${hasDoc ? 'completed' : (doc.required ? 'required' : '')}">
                                <strong>${doc.title}</strong><br>
                                ${doc.description}<br>
                                Status: ${hasDoc ? '‚úÖ Uploaded' : (doc.required ? '‚ö†Ô∏è Required' : 'üìã Optional')}
                            </div>
                        `;
                    }
                }
                
                const html = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>GRC Application Checklist</title>
                        <style>
                            body { font-family: Arial, sans-serif; padding: 20px; }
                            h1, h2 { color: #333; }
                            .section { margin-bottom: 30px; }
                            .item { margin: 10px 0; padding: 10px; border: 1px solid #ddd; }
                            .completed { background: #e8f5e9; }
                            .required { background: #ffebee; }
                            .timeline-info { background: #f0f4ff; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
                            @media print { body { font-size: 12pt; } }
                        </style>
                    </head>
                    <body>
                        <h1>GRC Application Checklist</h1>
                        <p>Generated: ${new Date().toLocaleDateString()}</p>
                        
                        <div class="timeline-info">
                            <h2>Application Eligibility Status</h2>
                            <p><strong>Earliest Application Date:</strong> ${this.formatDate(this.targetDate)}</p>
                            <p><strong>Status:</strong> ${timeRemaining.text}</p>
                            <p><strong>Evidence Collection Period:</strong> ${this.formatDate(this.startDate)} - ${this.formatDate(this.targetDate)}</p>
                            ${timeRemaining.eligible ? '<p style="color: green;"><strong>üéâ Congratulations! You have completed the mandatory waiting period and are now eligible to apply for your Gender Recognition Certificate!</strong></p>' : '<p><em>The UK requires a 2-year waiting period before you can apply for a Gender Recognition Certificate. Use this time to collect evidence of living in your acquired gender.</em></p>'}
                        </div>
                        
                        <div class="section">
                            <h2>Evidence Timeline</h2>
                            ${quartersHtml}
                        </div>
                        
                        <div class="section">
                            <h2>Required Documents</h2>
                            ${documentsHtml}
                        </div>
                    </body>
                    </html>
                `;
                
                printWindow.document.write(html);
                printWindow.document.close();
                printWindow.print();
            }
        }

        // Global instance
        let tracker;

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            tracker = new GRCTracker();
        });

        // Global functions (updated for async)
        async function openQuarterModal(quarterId) {
            const modal = document.getElementById('quarter-modal');
            const quarters = tracker.getQuarters();
            const quarter = quarters.find(q => q.id === quarterId);
            
            if (!quarter) return;
            
            tracker.currentQuarter = quarterId;
            
            // Update modal title
            document.getElementById('modal-title').textContent = `${quarter.name} Evidence`;
            
            // Load existing notes
            const quarterData = tracker.data.quarters[quarterId];
            const notesTextarea = document.getElementById('quarter-notes');
            notesTextarea.value = quarterData?.notes || '';
            
            // Render existing files
            await tracker.renderQuarterFiles();
            
            // Show modal
            modal.style.display = 'block';
        }

        function closeModal() {
            document.getElementById('quarter-modal').style.display = 'none';
            tracker.currentQuarter = null;
        }

        function switchCategory(category) {
            // Update tabs
            document.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`tab-${category}`).classList.add('active');
            
            // Update content
            document.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`content-${category}`).classList.add('active');
            
            tracker.currentCategory = category;
        }

        async function uploadCategoryDocument(category, docId) {
            // Create temporary file input
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = '*/*';
            
            input.onchange = async (e) => {
                const files = Array.from(e.target.files);
                
                if (!tracker.data.documents[category][docId]) {
                    tracker.data.documents[category][docId] = { fileCount: 0 };
                }
                
                for (const file of files) {
                    try {
                        const arrayBuffer = await tracker.readFileAsArrayBuffer(file);
                        
                        if (tracker.storage) {
                            await tracker.storage.saveFile({
                                name: file.name,
                                size: file.size,
                                type: file.type,
                                data: arrayBuffer,
                                uploadDate: new Date().toISOString(),
                                category: category,
                                docId: docId
                            });
                        }
                        
                        tracker.data.documents[category][docId].fileCount = 
                            (tracker.data.documents[category][docId].fileCount || 0) + 1;
                        
                        // Show success message
                        alert(`‚úÖ ${file.name} uploaded successfully!`);
                    } catch (error) {
                        console.error('Error uploading file:', error);
                        alert(`‚ùå Error uploading ${file.name}: ${error.message}`);
                    }
                }
                
                await tracker.saveData();
                await tracker.render();
            };
            
            input.click();
        }

        async function viewDocumentFiles(category, docId) {
            const files = await tracker.getDocumentFiles(category, docId);
            if (files.length === 0) return;
            
            // For now, just download the first file
            const file = files[0];
            const blob = new Blob([file.data], { type: file.type });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = file.name;
            link.click();
            URL.revokeObjectURL(url);
        }

        async function deleteCategoryDocument(category, docId) {
            const files = await tracker.getDocumentFiles(category, docId);
            if (files.length === 0) return;
            
            const docTitle = tracker.documentDefs[category].find(d => d.id === docId)?.title || 'document';
            
            if (files.length === 1) {
                // Single file - simple confirmation
                if (confirm(`‚ö†Ô∏è Are you sure you want to delete the uploaded ${docTitle}?\n\nThis action cannot be undone.`)) {
                    await tracker.storage.deleteFile(files[0].id);
                    delete tracker.data.documents[category][docId];
                    await tracker.saveData();
                    await tracker.render();
                    alert(`‚úÖ ${docTitle} deleted successfully.`);
                }
            } else {
                // Multiple files - show list to choose from
                let fileList = files.map((file, index) => `${index + 1}. ${file.name}`).join('\n');
                let choice = prompt(`Multiple files found for ${docTitle}:\n\n${fileList}\n\nEnter the number of the file to delete (1-${files.length}), or type "ALL" to delete all files:`);
                
                if (choice === null) return; // User cancelled
                
                if (choice.toUpperCase() === 'ALL') {
                    if (confirm(`‚ö†Ô∏è Are you sure you want to delete ALL ${files.length} files for ${docTitle}?\n\nThis action cannot be undone.`)) {
                        for (const file of files) {
                            await tracker.storage.deleteFile(file.id);
                        }
                        delete tracker.data.documents[category][docId];
                        await tracker.saveData();
                        await tracker.render();
                        alert(`‚úÖ All files for ${docTitle} deleted successfully.`);
                    }
                } else {
                    const fileIndex = parseInt(choice) - 1;
                    if (isNaN(fileIndex) || fileIndex < 0 || fileIndex >= files.length) {
                        alert('‚ùå Invalid file number. Please try again.');
                        return;
                    }
                    
                    const fileName = files[fileIndex].name;
                    if (confirm(`‚ö†Ô∏è Are you sure you want to delete "${fileName}"?\n\nThis action cannot be undone.`)) {
                        await tracker.storage.deleteFile(files[fileIndex].id);
                        
                        tracker.data.documents[category][docId].fileCount = Math.max(0,
                            (tracker.data.documents[category][docId].fileCount || 1) - 1);
                        
                        // If no files left, remove the entire document entry
                        if (tracker.data.documents[category][docId].fileCount === 0) {
                            delete tracker.data.documents[category][docId];
                        }
                        
                        await tracker.saveData();
                        await tracker.render();
                        alert(`‚úÖ "${fileName}" deleted successfully.`);
                    }
                }
            }
        }

        // Drag and drop handlers
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('upload-area').classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('upload-area').classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('upload-area').classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                tracker.handleFileUpload(files);
            }
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                tracker.handleFileUpload(files);
            }
        }

        async function importBackup(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate the data structure
                    if (!importedData.quarters || !importedData.documents) {
                        throw new Error('Invalid backup file format');
                    }
                    
                    // Ensure settings exist and have targetDate
                    if (!importedData.settings) {
                        importedData.settings = { targetDate: '2025-12-01' };
                    }
                    if (!importedData.settings.targetDate) {
                        importedData.settings.targetDate = '2025-12-01';
                    }
                    
                    // Confirm before importing
                    if (confirm('This will replace all your current data. Are you sure you want to import this backup?\n\nNote: File data is not included in backups and will need to be re-uploaded.')) {
                        tracker.data = importedData;
                        await tracker.saveData();
                        tracker.updateDatesFromSettings();
                        await tracker.render();
                        
                        alert('‚úÖ Backup imported successfully!\n\nNote: You will need to re-upload your files as they are not included in backups.');
                    }
                } catch (error) {
                    alert('‚ùå Error importing backup: ' + error.message);
                }
                
                // Reset the input
                input.value = '';
            };
            
            reader.readAsText(file);
        }

        async function updateTargetDate(dateString) {
            if (tracker && tracker.isInitialized) {
                await tracker.updateTargetDate(dateString);
            }
        }

        async function clearAllData() {
            if (confirm('‚ö†Ô∏è This will permanently delete all your data including uploaded files. Are you sure?')) {
                if (confirm('‚ö†Ô∏è This action cannot be undone. Please confirm again.')) {
                    // Preserve the current target date setting
                    const currentTargetDate = tracker.data.settings.targetDate;
                    
                    // Clear IndexedDB
                    if (tracker.storage) {
                        await tracker.storage.clearAllData();
                    }
                    
                    tracker.data = {
                        quarters: {},
                        documents: {
                            core: {},
                            medical: {},
                            name: {},
                            marriage: {}
                        },
                        notes: {},
                        settings: {
                            targetDate: currentTargetDate
                        }
                    };
                    await tracker.saveData();
                    tracker.updateDatesFromSettings();
                    await tracker.render();
                    
                    alert('‚úÖ All data has been cleared.');
                }
            }
        }

        // Modal close on outside click
        window.onclick = (e) => {
            const modal = document.getElementById('quarter-modal');
            if (e.target === modal) {
                closeModal();
            }
        };

        // Export functions to global scope
        window.openQuarterModal = openQuarterModal;
        window.closeModal = closeModal;
        window.switchCategory = switchCategory;
        window.uploadCategoryDocument = uploadCategoryDocument;
        window.viewDocumentFiles = viewDocumentFiles;
        window.deleteCategoryDocument = deleteCategoryDocument;
        window.handleDragOver = handleDragOver;
        window.handleDragLeave = handleDragLeave;
        window.handleDrop = handleDrop;
        window.handleFileSelect = handleFileSelect;
        window.exportProgress = () => tracker.exportProgress();
        window.exportBackup = () => tracker.exportBackup();
        window.printChecklist = () => tracker.printChecklist();
        window.importBackup = importBackup;
        window.clearAllData = clearAllData;
        window.updateTargetDate = updateTargetDate;
    </script>
</body>
</html>
